---
title: "Predict Microbial Community"
subtitle: "Script 4: Predicting fungal communities from soil properties"
author: Natacha Bodenhausen
date: '`r Sys.Date()`'
output:
  pdf_document:
        toc: yes
urlcolor: blue
---


```{r setup, include=FALSE}


#libraries
knitr::opts_chunk$set(echo = FALSE, cache = FALSE)
suppressPackageStartupMessages(library(tidyverse))
library(vegan) # not sure if it necessary because it is in phyloseq
library("phyloseq")
library("kableExtra") # to style the tables 
library(soiltexture) # ternary plot
library(ggcorrplot) # correlogram
#library("factoextra") # plot PCA results
# library(gplots) #heatmap.2
library(gridExtra) ## grid_arrange
library(cowplot) # plot_grid => several plots in one figure
library(viridis) # color for people with colorblindness  
library(ggrepel) # geom_text_repel


# same color as ggplot
gg_color_hue <- function(n) {
  hues = seq(15, 375, length = n + 1)
  hcl(h = hues, l = 65, c = 100)[1:n]
}

set.seed(8037)

# logical: would you like figures?
makeFig <- TRUE

# logical: we would you like to work with first sequencing  
# where each year was sequenced separately or not (m11)
m1m8m9 <- TRUE

# logical: would you like to save R objects for the next scripts?
saveRObjects <- FALSE

```


```{r}

my_theme <- theme_bw() +
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank())

  
theme_main <- theme(text = element_text(size = 10))

theme_supp <- theme(text = element_text(size = 10))

theme_presentation <-theme(text = element_text(size = 20))


```

\newpage

# Material and methods 

## 2018

22 fields were sampled in the spring 2018

4 DNA extractions per field done by Alain in the summer 2018.

ITS1F and ITS4 primers were used to amplify both ITS1 and ITS2.

Library "microbial1" was prepared by Alain at Reckenholz and sequenced by FGCZ.


## 2019

25 fields were sampled in the spring 2019

4 DNA extractions per field done by Alain in the spring 2020.

ITS1F and ITS4 primers were used to amplify both ITS1 and ITS2.

Library "microbial6" was prepared by Markus at UniBasel and sequenced by Unibern.

Quality of sequencing really bad, so Gabriel prepared a second library, called "microbial8".

## 2020

12 fields were sampled in the spring 2020

4 DNA extractions per field  done by Alain in the winter 2021.

ITS1F and ITS4 primers were used to amplify both ITS1 and ITS2.

Library "microbial9" was prepared by Gabriel at Uni Basel and sequenced in Bern.

## 2022

All samples were resequenced in a fourth library "microbial11" in 2022. The four DNA replicates were pooled before the PCR, so there is only one PCR per field.


## Bioinformatics

Prepared by Jan Wälchli with new taxonomy from November 2021.


```{r}
print("This script uses either data from the three librairies (m1m8m9) or fourth library(m11)")
```

```{r, echo = TRUE}

print(m1m8m9)

```



\newpage



```{r}
if(m1m8m9 == TRUE){
  load(file="../results/physeq_m1_m8_m9_norm.rda")
} else {
   load(file="../results/physeq_m11_norm.rda")
  }

load(file="../results/soil_selected.rda")

# add soil variables to the phyloseq object
design_table <- data.frame(sample_data(physeq_norm))

design_table <-left_join(design_table,
                         soil_selected, by ="field") %>%
  tibble::column_to_rownames("field")

sample_data(physeq_norm) <- design_table

# we need a variable field
sample_data(physeq_norm)$field <- sample_names(physeq_norm)



```

```{r}

env_data <-data.frame(sample_data(physeq_norm))
# variable_selection<- env_data %>% dplyr::select(-field,- library, - year)
reduced_set<- env_data %>% dplyr::select(Mg:Na)

# OTU
taxonTable <-otu_table(physeq_norm, taxa_are_rows = FALSE)
taxon_table_hell <- sqrt(taxonTable) # hellinger is sqrt relative abundance

```

\newpage

# prediction with RDA


## species prediction with RDA

remove the first site, create a new model with missing site, predict the "response" from the leave-one-out model.

NEW: model selection is inside the loop

 
```{r, fig.height=8, eval = FALSE, message= FALSE, warning=FALSE}

response_predicted_rda <- data.frame()


model_leave_one_out <- list()


# leave one out
for(i in seq(1,nrow(reduced_set), by = 1)){

Y_measured<- reduced_set[i,]
Z_measured <-env_data[i,]

stopifnot(identical(rownames(taxon_table_hell)[i], rownames(Y_measured)))

X_new <-taxon_table_hell[-i, ]
Y_new <-reduced_set[-i,]
Z_new <-env_data[-i,]

# for variable selection with ordiR2step() we need two models
mod0<- rda(X_new ~ Condition(Z_new$library), 
            data = Y_new) 

mod1 <- rda(X_new ~ .+Condition(Z_new$library), data = Y_new)

adjR2.tbrda <- RsquareAdj(mod1)$adj.r.squared

mod3<- ordiR2step (mod0, scope = formula(mod1), R2scope = adjR2.tbrda, direction = 'forward', permutations = 99, trace = FALSE)

# save the names of the variables in the model
new_variables <-rownames(mod3$CCA$biplot)

Y_selected <-Y_new %>%
  dplyr::select(all_of(new_variables))


spe.rda_loo <- rda( X_new ~ Condition(Z_new$library)+., Y_selected)

# Function predict can find the estimate of the original data matrix or dissimilarities (type = "response") with any rank. 

## to do: the output is a list

response_predicted_i<-predict(spe.rda_loo, 
                              type="response",
                              new=Y_measured) 
# there are three sets of prediction, one for each library
one_per_library <-unique(as.data.frame(response_predicted_i))

#head(t(one_per_library))

if(Z_measured$library ==2018){
  j <-1
  } else if(Z_measured$library ==2019){
  j <-2
  } else if(Z_measured$library ==2020){
  j <-3
  }

response_predicted_rda<-rbind(response_predicted_rda, one_per_library[j,])

rownames(response_predicted_rda)[i]<-Z_measured$field

# collect all the models

model_leave_one_out[[paste0("F", formatC(i,width = 2, format = "d", flag = "0"))]] <-new_variables


}

model_leave_one_out

if(saveRObjects == TRUE){
  save(model_leave_one_out , file = "../results/model_leave_one_out.rda")
}

if(saveRObjects == TRUE){
  save(response_predicted_rda , file = "../results/response_predicted.rda")
}

```


```{r}

load(file="../results/model_leave_one_out.rda")

load(file="../results/response_predicted.rda")

```


\newpage

# Root Mean Square Error

```{r}

observed_values  <- as.data.frame(taxon_table_hell)
#RMSE is the mean of  the differences between the predicted values and the observed values 
stopifnot(identical(rownames(observed_values), rownames(response_predicted_rda)))

stopifnot(identical(colnames(observed_values), colnames(response_predicted_rda)))


diff<-observed_values-response_predicted_rda

n_obs<-ncol(observed_values)

root_mean_square_error <-sqrt(rowSums(diff^2)/n_obs)

# check with metrics::rmse 
# rmse(t(observed_values[1,]),t(response_predicted_rda[1,]))

```

## plot RMSE (barplot)

```{r}

# making a tibble
for_plot_rmse<- tibble("rmse" = root_mean_square_error,
                       "field" = names(root_mean_square_error))

# adding library
for_plot_rmse <- left_join(for_plot_rmse, 
                       env_data %>% 
                         dplyr::select("field", "library"), 
                       by = "field")

```

```{r}

#for_plot_rmse %>% arrange(desc(-rmse))

plot_rmse<- ggplot(dat = for_plot_rmse, 
                      aes(x = reorder(field,rmse), 
                         y = rmse, fill  = library))+
geom_col()+
 coord_cartesian(ylim=c(0.0,0.5))+
theme_bw() +
  theme(axis.text.x = 
          element_text( angle=90, size = 8, 
                        hjust = 1, vjust = 0.5))+
  theme(axis.title.x =  element_blank())+
  theme(legend.position = "none")+
  labs(y="RMSE")+
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank())

plot_rmse

# ggsave("../figures/predict_sites_rmse.pdf",
#        plot_pearson + theme_main,
#        width = 18, height=14, units="cm")

```

From the paper: 

"The fields with highest RMSE (poor prediction) were F02, F15 and F30."

```{r}
for_plot_rmse %>% filter(rmse>0.4)

```

\newpage

# heatmap of all the leave-one-out models


```{r}



for_gg <- model_leave_one_out %>%
  enframe(name = "field", value = "soil_property")%>%
  add_column(present = TRUE) %>%
  unnest(cols = "soil_property") %>%
  # later one replace as_factor(...) by factor(..., my_levels) 
  # mylevels specifies the order I want to see
  mutate(soil_property = as_factor(.data$soil_property)) %>%
  mutate(field = factor(.data$field, 
                        levels = names(model_leave_one_out)))%>% 
  complete(.data$field, .data$soil_property, fill = list(present = FALSE))


wide_heatmap <-for_gg  %>%
  pivot_wider(id_cols = soil_property,
              names_from = field ,
              values_from = present)

wide_heatmap <- wide_heatmap %>%
  column_to_rownames("soil_property")

```

## variables are odered by number of times they appear in the model, fields by RMSE

```{r}

## order  variables   by number of times they appear in the model
sum_appearance <-rowSums(wide_heatmap)

sum_appearance <-sum_appearance[order(sum_appearance,decreasing = TRUE)]

order_soil <-names(sum_appearance)



for_gg$soil_property3 <-factor(for_gg$soil_property, 
                        levels = order_soil)


## order  fields   by RMSE

root_mean_square_error <-root_mean_square_error[order(root_mean_square_error,decreasing = FALSE)]

order_field <-names(root_mean_square_error)



for_gg$field3 <-factor(for_gg$field, 
                        levels = order_field)

# plot

heat_map <-ggplot(for_gg, 
                  aes(x = field3, 
                      y = soil_property3, 
                      fill = present))+
  geom_tile()+
  theme_bw() +
  theme(legend.position = "none")+
  theme(axis.text.x = 
          element_text(angle = 90, 
                       vjust = 0.5, 
                       hjust=1),
        rect = element_blank(),
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank())+
  labs(x = "", y = "")

heat_map


```

## Supplemental figure S11

```{r}






if(makeFig == TRUE) ggsave("../figures/RMSE_heatmap.pdf",
     plot_grid(plot_rmse + theme_main,
          heat_map + theme_main, 
          ncol = 1, align = 'v', 
          axis = 'l',
          labels=c("A","B")),
       width = 24, 
       height = 16, 
       units = "cm")



```


# Pearson correlation of fields

```{r, eval = TRUE}

xx <-t(as.matrix(taxon_table_hell))

corr_all_sites <-diag(cor(t(response_predicted_rda), t(as.matrix(taxon_table_hell)), method = "pearson"))

# adding field
for_plot_pearson<- data.frame("corr" = corr_all_sites, "field" = rownames(taxon_table_hell))

# adding library
for_plot_pearson <- left_join(for_plot_pearson, 
                              env_data %>% dplyr::select("field", "library"), by = "field")

#for_gg <- for_gg %>% arrange(desc(corr))

```

```{r}

plot_pearson<- ggplot(dat = for_plot_pearson, 
                      aes(x = reorder(field,-corr), 
                         y = corr, fill  = library))+
geom_col()+
 coord_cartesian(ylim=c(0.0,0.9))+
  geom_hline(yintercept = 0.7, col = "grey")+
    geom_hline(yintercept = 0.5, col = "grey")+
theme_bw() +
  theme(axis.text.x = 
          element_text( angle=90, size = 8, 
                        hjust = 1, vjust = 0.5))+
  theme(axis.title.x =  element_blank())+
  theme(legend.position = "none")+
  ylab("Correlation coefficient")+
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank())

plot_pearson

# ggsave("../figures/predict_sites_pearson.pdf",
#        plot_pearson + theme_main,
#        width = 18, height=14, units="cm")

```

## some sentences in the text

"For more than half of the soils, the model predicted well (Pearson r > 0.7) the abundances of individual community members (Figure 5A). Predictions were fair (Pearson 0.7 > r > 0.5) for 15/59 fields while in only three fields (namely, F02, F30, and F46), the predicted abundances did not agree (Pearson’s r < 0.5) with the observed community data."


```{r, echo = TRUE}


nrow(for_plot_pearson %>% filter(corr>.7))/nrow(for_plot_pearson)

for_plot_pearson %>% 
       dplyr::filter(corr<0.7 & corr >0.5  ) %>%
  count()

```



```{r}
for_plot_pearson %>% filter(corr<.5)

```





\newpage

## mini-plots

```{r, function_for_miniplot}

mini_plot <- function(field, 
                      obsverved_otu,
                      predicted_otu ){
  
  
  observed<- as.data.frame(obsverved_otu[field,])
  
  predicted <- predicted_otu[field,]
  
   stopifnot(all(identical(names(observed), names(predicted))))
 
 plot_correlation <- data.frame(t(observed),  t(predicted ))
 
 colnames(plot_correlation) <- c("observed", "predicted")
 
  plot_correlation <- plot_correlation %>% rownames_to_column("otu")
 
 cor_value <- cor(plot_correlation$observed,
                  plot_correlation$predicted, 
                  method = "pearson")
 
 mylabel = bquote(italic(r) == .(format(cor_value, digits = 3)))
 
my_title <- paste(field, ", r =",format(cor_value, digits = 3))

 
my_plot <- ggplot(plot_correlation, 
        aes(x= observed, y  = predicted))+
   geom_point( size = 1)+
  geom_text_repel(dat = 
              plot_correlation %>% 
                filter(predicted > 2.5|observed > 2.5),
            aes(label = otu),  
            segment.linetype = 5, size = 2)+
  geom_abline(slope = 1, intercept = 0)+
   theme_test()+
  #xlim(0,6)+
  # ylim(-0.3,5.7)+
   ggtitle(my_title)

#print(my_plot) 
}
  
 
 # use geom_label_repel
# see https://stackoverflow.com/questions/18337653/remove-a-from-legend-when-using-aesthetics-and-geom-text

```

```{r}

# max 13
# which(for_plot_pearson$corr==max(for_plot_pearson$corr))
# 
# for_plot_pearson[13,]


best_field <-mini_plot(field = "F13", 
                       obsverved_otu = taxon_table_hell,  
                       predicted_otu = response_predicted_rda) +
  theme_main

# median 42

# which(for_plot_pearson$corr==median(for_plot_pearson$corr))
# for_plot_pearson[42,]

median_field <-mini_plot(field = "F42", 
                       obsverved_otu = taxon_table_hell,  
                       predicted_otu = response_predicted_rda) +
  theme_main


worse_field <-mini_plot(field = "F30", 
                       obsverved_otu = taxon_table_hell,  
                       predicted_otu = response_predicted_rda) +
  theme_main




# min 30
# which(for_plot_pearson$corr==min(for_plot_pearson$corr))
# 
# for_plot_pearson[2,]







```

```{r}

good_median_bad <- plot_grid(best_field,
                             median_field,
                             worse_field, 
                     labels = c('B', 'C','D'),
                        label_size = 12, 
                     ncol = 3)

new_top <- plot_grid(plot_pearson+ theme_main, labels = c('A'))


plot_grid(new_top, good_median_bad, nrow= 2)


if(makeFig == TRUE) ggsave("../figures/Pearson_correlation_plot_grid.pdf",
       plot_grid(new_top, good_median_bad, nrow= 2),
       width = 17, 
       height = 12, 
       units = "cm")

  


```

\newpage

## relationship between (R)MSE and correlation coefficient

```{r}
corr_rmse <- left_join(for_plot_pearson, for_plot_rmse, by = "field")

cor.test(corr_rmse$corr, corr_rmse$rmse )

p1 <-ggplot(corr_rmse, aes ( x = corr, y = rmse^2))+
  geom_point()+
  stat_smooth(method  = "lm")

p2 <- ggplot(corr_rmse, aes ( x = corr, y = rmse))+
  geom_point()+
  stat_smooth(method  = "lm")

plot_grid(p1+ theme_main, 
                    p2+ theme_main, nrow = 1)


if(makeFig == TRUE)
  ggsave( "../figures/corr_mse.pdf", 
          plot_grid(p1+ theme_main, 
                    p2+ theme_main, nrow = 1),  
          width = 16, 
          height = 8, 
          units = "cm")
```


\newpage


# Explaining bad prediction

```{r}
load("../results/max_distance.rda")
load("../results/all_soil.rda")
load("../results/m1_m8_m9_tree_cluster.rda")

## to do: there has to be a smarter way!
all_dat <-  inner_join(for_plot_pearson,
                       max_distance, 
                       by = "field") %>%
  inner_join( table_S1 %>%dplyr::select(soil_texture, 
                       field), 
            by = "field") %>%
  inner_join(tree_cluster, by = "field" )


```


## Supplemental figure XX



## A) soil texture classes

```{r}
model5 <- lm(corr ~ as.factor(soil_texture), dat = all_dat)

summary(model5)

P <- signif(anova(model5)$'Pr(>F)'[1],4)

F <- signif(with(summary(model5), fstatistic[1]),3)


aa<- ggplot(all_dat, aes( x = soil_texture, 
                     y = corr)) +
  #geom_boxplot()+
  geom_text_repel(dat = all_dat %>% filter(corr<0.5), aes(label = field), nudge_x = 0.3)+
  geom_dotplot(aes(fill = soil_texture),
               binaxis = "y", 
               stackdir = "center")+
  labs( x = "",
        y = "Correlation coefficient",
        title = "Soil texture",
       subtitle = 
         paste("F = ", F,", P =", P))+
  my_theme+
  theme(legend.position = "none")


#print(aa)
```

## B) library

```{r}
model4 <- lm(corr ~ as.factor(library), dat = all_dat)

summary(model4)

anova(model4)

P <- signif(anova(model4)$'Pr(>F)'[1],3)

F <- signif(with(summary(model4), fstatistic[1]),3)

bb <-ggplot(all_dat, aes( x = library, 
                     y = corr)) +
  #geom_boxplot()+
   geom_text_repel(dat = all_dat %>% filter(corr<0.5), aes(label = field), segment.linetype = 5)+
  geom_dotplot(aes(fill = library),
               binaxis = "y", 
               stackdir = "center")+
  labs( x = "",
        y = "Correlation coefficient",
        title = "Library",
       subtitle = 
         paste("F = ", F,", P =", P))+
  my_theme+
  theme(legend.position = "none")
  



#print(bb)

#TukeyHSD(aov(model4))

```



## C) max distance 

```{r}
model3 <- lm(corr ~ max_distance,
             dat = all_dat)

summary(model3)


P <- signif(anova(model3)$'Pr(>F)'[1],3)

r2 <- signif(summary(model3)$adj.r.squared, 3)

cc <- ggplot(all_dat, 
             aes( x = max_distance, 
                     y = corr,
                     col = library)) +
  geom_text(aes(label = field))+
  labs( x = "Max Bray-Curtis",
        y = "Correlation Coefficient",
        title = "Dissimilarity",
       subtitle = 
         paste("Adj R2 = ", r2,", P =", P))+
  stat_smooth(method = "lm", col = "red") +
  my_theme+
  theme(legend.position = "none")
  

#print(cc)

#ggsave("../figures/figure_like_loic_bray.pdf")

```







## D) cluster in core community

```{r}

model6 <- lm(corr ~ as.factor(new_cluster), dat = all_dat)

summary(model6)

P <- signif(anova(model6)$'Pr(>F)'[1],3)

F <- signif(with(summary(model6), fstatistic[1]),3)



dd <- ggplot(all_dat, aes( x = as.factor(new_cluster), 
                     y = corr)) +
  #geom_boxplot()+
  geom_text_repel(dat = all_dat %>% filter(corr<0.5), aes(label = field))+
  # geom_text(dat = all_dat %>% filter(corr<0.6), aes(label = field), nudge_x = 0.2)+
  geom_dotplot(aes(fill = as.factor(new_cluster)),
               binaxis = "y", 
               stackdir = "center")+
  labs( x = "",
        y = "Correlation coefficient",
        title = "Core cluster",
       subtitle = 
         paste("F = ", F,", P =", P))+
  my_theme+
  theme(legend.position = "none")



#print(dd)

#TukeyHSD(aov(model6))

```

\newpage


##  Supplemental Figure S12

```{r, eval = TRUE}

plot_texture <- plot_grid(aa + theme_main,
                  labels = c('A'),
                  label_size = 12)


plot_year <- plot_grid(bb + theme_main,
                  labels = c('B'),
                  label_size = 12)


plot_distance <- plot_grid(cc + theme_main,
                  labels = c('C'),
                  label_size = 12)


plot_core <- plot_grid(dd + theme_main,
                  labels = c('D'),
                  label_size = 12)



plot_grid(plot_texture,
          plot_year,
          plot_distance, 
          plot_core, 
          ncol = 2)


if(makeFig == TRUE) ggsave("../figures/Explaining_prediction.pdf",
       plot_grid(plot_texture,
          plot_year,
          plot_distance, 
          plot_core, 
          ncol = 2),
       width = 17, 
       height = 17, 
       units = "cm")



```

\newpage

## taxonomy of a few special OTUs

OTUs which are in the mini-plots

```{r}

tax <-tax_table(physeq_norm) %>%
  as.data.frame %>%
  rownames_to_column("otu") 


tax%>%filter(otu =="OTU1")
tax%>%filter(otu =="OTU2")

#F30
tax%>%filter(otu =="OTU26")

tax%>%filter(otu =="OTU45")

tax%>%filter(otu =="OTU7")





```


